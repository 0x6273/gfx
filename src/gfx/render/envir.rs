// Copyright 2014 The Gfx-rs Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

extern crate time;
use device::shade::{UniformValue, ProgramMeta};

/// A supposedly unique mark to distinguish between variables
/// generated by different Storage objects.
type Mark = u16;
type BlockId = u8;
type UniformId = u16;
type TextureId = u8;
pub struct BlockVar(BlockId, Mark);
pub struct UniformVar(UniformId, Mark);
pub struct TextureVar(TextureId, Mark);


/// Environment storage structure, contains a set of parameters
/// to be provided for shader programs
pub struct Storage {
    mark: Mark,
    blocks: Vec<(String, super::BufferHandle)>,
    uniforms: Vec<(String, UniformValue)>,
    textures: Vec<(String, super::TextureHandle, super::SamplerHandle)>,
}

impl Storage {
    pub fn new() -> Storage {
        Storage {
            mark: time::get_time().nsec as Mark,
            blocks: Vec::new(),
            uniforms: Vec::new(),
            textures: Vec::new(),
        }
    }

    // expansion methods

    pub fn add_block(&mut self, name: &str, buf: super::BufferHandle) -> BlockVar {
        self.blocks.push((name.to_string(), buf));
        BlockVar((self.blocks.len() - 1) as BlockId, self.mark)
    }

    pub fn add_uniform(&mut self, name: &str, value: UniformValue) -> UniformVar {
        self.uniforms.push((name.to_string(), value));
        UniformVar((self.uniforms.len() - 1) as UniformId, self.mark)
    }

    pub fn add_texture(&mut self, name: &str, texture: super::TextureHandle, sampler: super::SamplerHandle) -> TextureVar {
        self.textures.push((name.to_string(), texture, sampler));
        TextureVar((self.textures.len() - 1) as TextureId, self.mark)
    }

    // mutation methods

    pub fn set_block(&mut self, var: BlockVar, buf: super::BufferHandle) {
        let BlockVar(id, mark) = var;
        debug_assert_eq!(mark, self.mark);
        let &(_, ref mut block) = self.blocks.get_mut(id as uint);
        *block = buf;
    }
    
    pub fn set_uniform(&mut self, var: UniformVar, value: UniformValue) {
        let UniformVar(id, mark) = var;
        debug_assert_eq!(mark, self.mark);
        let &(_, ref mut uniform) = self.uniforms.get_mut(id as uint);
        *uniform = value;
    }

    pub fn set_texture(&mut self, var: TextureVar, texture: super::TextureHandle, sampler: super::SamplerHandle) {
        let TextureVar(id, mark) = var;
        debug_assert_eq!(mark, self.mark);
        let &(_, ref mut tex, ref mut sam) = self.textures.get_mut(id as uint);
        *tex = texture;
        *sam = sampler;
    }
}


/// Moving the unsafe accessors out of public interface
pub trait BindableStorage {
    fn get_block(&self, BlockId) -> super::BufferHandle;
    fn get_uniform(&self, UniformId) -> UniformValue;
    fn get_texture(&self, TextureId) -> (super::TextureHandle, super::SamplerHandle);
}

impl BindableStorage for Storage {
    fn get_block(&self, id: BlockId) -> super::BufferHandle {
        let &(_, buf) = self.blocks.get(id as uint);
        buf
    }

    fn get_uniform(&self, id: UniformId) -> UniformValue {
        let &(_, value) = self.uniforms.get(id as uint);
        value
    }

    fn get_texture(&self, id: TextureId) -> (super::TextureHandle, super::SamplerHandle) {
        let &(_, texture, sampler) = self.textures.get(id as uint);
        (texture, sampler)
    }
}


/// Environment shortcut - the acceleration structure used for
/// binding shader program parameters. Each *Var serves as a
/// pointer from a program parameter to the environment data.
pub struct Shortcut {
    pub blocks: Vec<BlockId>,
    pub uniforms: Vec<UniformId>,
    pub textures: Vec<TextureId>,
}

impl Shortcut {
    pub fn is_fit(&self, program: &ProgramMeta) -> bool {
        self.blocks.len() == program.blocks.len() &&
        self.uniforms.len() == program.uniforms.len() &&
        self.textures.len() == program.textures.len()
    }

    pub fn build(storage: &Storage, program: &ProgramMeta) -> Result<Shortcut,()> {
        let sh = Shortcut {
            blocks: program.blocks.iter().scan((), |_, b|
                storage.blocks.iter().position(|&(ref name,_)| name==&b.name).map(|p| p as BlockId)
                ).collect(),
            uniforms: program.uniforms.iter().scan((), |_, u|
                storage.uniforms.iter().position(|&(ref name, _)| name==&u.name).map(|p| p as UniformId)
                ).collect(),
            textures: program.textures.iter().scan((), |_, t|
                storage.textures.iter().position(|&(ref name, _, _)| name==&t.name).map(|p| p as TextureId)
                ).collect(),
        };
        if sh.is_fit(program) {Ok(sh)}
        else {Err(())}
    }
}
