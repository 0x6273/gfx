// Copyright 2014 The Gfx-rs Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

extern crate time;
extern crate syntax;


use device::shade::{UniformValue, ProgramMeta, CompatibilityError};

use std::iter::Map;
use std::slice::Items;

/// A supposedly unique mark to distinguish between variables
/// generated by different Storage objects.
type Mark = u16;
pub type BlockId = u8;
pub type UniformId = u16;
pub type TextureId = u8;
pub struct BlockVar(BlockId, Mark);
pub struct UniformVar(UniformId, Mark);
pub struct TextureVar(TextureId, Mark);

/// Environment storage structure, contains a set of parameters
/// to be provided for shader programs
pub struct Storage {
    mark: Mark,
    blocks: Vec<(String, super::BufferHandle)>,
    uniforms: Vec<(String, UniformValue)>,
    textures: Vec<(String, super::TextureHandle, super::SamplerHandle)>,
}

impl Storage {
    pub fn new() -> Storage {
        Storage {
            mark: time::get_time().nsec as Mark,
            blocks: Vec::new(),
            uniforms: Vec::new(),
            textures: Vec::new(),
        }
    }

    // expansion methods

    pub fn add_block(&mut self, name: &str, buf: super::BufferHandle) -> BlockVar {
        self.blocks.push((name.to_string(), buf));
        BlockVar((self.blocks.len() - 1) as BlockId, self.mark)
    }

    pub fn add_uniform(&mut self, name: &str, value: UniformValue) -> UniformVar {
        self.uniforms.push((name.to_string(), value));
        UniformVar((self.uniforms.len() - 1) as UniformId, self.mark)
    }

    pub fn add_texture(&mut self, name: &str, texture: super::TextureHandle, sampler: super::SamplerHandle) -> TextureVar {
        self.textures.push((name.to_string(), texture, sampler));
        TextureVar((self.textures.len() - 1) as TextureId, self.mark)
    }

    // mutation methods

    pub fn set_block(&mut self, var: BlockVar, buf: super::BufferHandle) {
        let BlockVar(id, mark) = var;
        debug_assert_eq!(mark, self.mark);
        let &(_, ref mut block) = self.blocks.get_mut(id as uint);
        *block = buf;
    }

    pub fn set_uniform(&mut self, var: UniformVar, value: UniformValue) {
        let UniformVar(id, mark) = var;
        debug_assert_eq!(mark, self.mark);
        let &(_, ref mut uniform) = self.uniforms.get_mut(id as uint);
        debug_assert!(!uniform.is_valid() || uniform.is_same_type(&value));
        *uniform = value;
    }

    pub fn set_texture(&mut self, var: TextureVar, texture: super::TextureHandle, sampler: super::SamplerHandle) {
        let TextureVar(id, mark) = var;
        debug_assert_eq!(mark, self.mark);
        let &(_, ref mut tex, ref mut sam) = self.textures.get_mut(id as uint);
        *tex = texture;
        *sam = sampler;
    }
}

/// Environment shortcut - the acceleration structure used for
/// binding shader program parameters. Each *Var serves as a
/// pointer from a program parameter to the environment data.
pub struct Shortcut {
    mark: Mark,
    pub blocks: Vec<BlockId>,
    pub uniforms: Vec<UniformId>,
    pub textures: Vec<TextureId>,
}

#[deriving(Show)]
pub enum OptimizeError<'a> {
    ErrorBlockNotFound(&'a str),
    ErrorUniformNotFound(&'a str),
    ErrorUniformFormat(&'a str, CompatibilityError),
    ErrorTextureNotFound(&'a str),
}

pub type BlockRecord = (String, super::BufferHandle);
pub type BufferIterator<'a> = Map<'a, &'a BlockRecord, super::BufferHandle, Items<'a, BlockRecord>>;

/// Moving the unsafe accessors out of public interface
pub trait BindableStorage {
    fn get_block(&self, BlockId) -> super::BufferHandle;
    fn get_uniform(&self, UniformId) -> UniformValue;
    fn get_texture(&self, TextureId) -> (super::TextureHandle, super::SamplerHandle);

    fn is_fit(&self, &Shortcut, &ProgramMeta) -> bool;
    fn iter_buffers<'a>(&'a self) -> BufferIterator<'a>;
    fn optimize<'a>(&self, &'a ProgramMeta) -> Result<Shortcut, OptimizeError<'a>>;
}

impl BindableStorage for Storage {
    fn get_block(&self, id: BlockId) -> super::BufferHandle {
        let (_, buf) = self.blocks[id as uint];
        buf
    }

    fn get_uniform(&self, id: UniformId) -> UniformValue {
        let (_, value) = self.uniforms[id as uint];
        value
    }

    fn get_texture(&self, id: TextureId) -> (super::TextureHandle, super::SamplerHandle) {
        let (_, texture, sampler) = self.textures[id as uint];
        (texture, sampler)
    }

    fn is_fit(&self, shortcut: &Shortcut, program: &ProgramMeta) -> bool {
        self.mark == shortcut.mark &&
        shortcut.blocks.len() == program.blocks.len() &&
        shortcut.uniforms.len() == program.uniforms.len() &&
        shortcut.textures.len() == program.textures.len()
    }

    fn iter_buffers<'a>(&'a self) -> BufferIterator<'a>   {
        self.blocks.iter().map(|&(_, handle)| handle)
    }

    fn optimize<'a>(&self, program: &'a ProgramMeta) -> Result<Shortcut, OptimizeError<'a>> {
        let mut cut = Shortcut {
            mark: self.mark,
            blocks: Vec::with_capacity(program.blocks.len()),
            uniforms: Vec::with_capacity(program.uniforms.len()),
            textures: Vec::with_capacity(program.textures.len()),
        };

        for block_var in program.blocks.iter() {
            let pos = match self.blocks.iter().position(|&(ref name, _)| name == &block_var.name) {
                Some(p) => p,
                None => return Err(ErrorBlockNotFound(block_var.name.as_slice()))
            };
            cut.blocks.push(pos as BlockId);
        }

        for uniform_var in program.uniforms.iter() {
            let pos = match self.uniforms.iter().position(|&(ref name, _)| name == &uniform_var.name) {
                Some(p) => p,
                None => return Err(ErrorUniformNotFound(uniform_var.name.as_slice()))
            };
            match uniform_var.is_compatible(self.uniforms[pos].ref1()) {
                Ok(_) => cut.uniforms.push(pos as UniformId),
                Err(e) => return Err(ErrorUniformFormat(uniform_var.name.as_slice(), e)),
            }
        }

        for texture_var in program.textures.iter() {
            let pos = match self.textures.iter().position(|&(ref name, _, _)| name == &texture_var.name) {
                Some(p) => p,
                None => return Err(ErrorTextureNotFound(texture_var.name.as_slice()))
            };
            // no semantics can be verified here, becase the actual texture format may differ between calls
            cut.textures.push(pos as TextureId);
        }

        Ok(cut)
    }
}
